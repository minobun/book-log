# 信頼性、スケーラビリティ、メンテナンス性に優れたアプリケーション

現在のアプリケーションはデータ志向

データベース：データを保存し、のちにそのアプリケーション自身、もしくはほかのアプリケーションがそのデータを再度見つけられるようにする。
キャッシュ：処理量の多い操作の結果を覚えておき、読み取りの速度を高める。
検索インデックス：ユーザーがデータをキーワードで検索したり、様々な方法でフィルタリングしたり、できるようにする。
ストリーム処理：ほかのプロセスへメッセージを送り、非同期に処理をしてもらう。
バッチ処理：蓄積された大量のデータを定期的に処理する。

データシステムでは様々なツールを包括する用語として利用される。

1. ツールの差異があいまいになってきている。
2. 複数のツールを利用してデータを管理するケースが増えている。

データシステムにおける三つの課題

1. 信頼性
2. スケーラビリティ
3. メンテナンス性

信頼性：何か問題が生じたとしても正しく動作し続けること
fault：問題を起こしうるもの、障害とは異なる
fault tolerant、resilient：fault の存在を見越して対処できること

## 信頼性

1. ハードウェアの障害
2. ソフトウェアのエラー
   1. ソフトウェアのバグ
   2. プロセスの暴走
   3. 依存しているサービスの問題
   4. カスケード障害
3. ヒューマンエラー

## スケーラビリティ

Twitter のポスト処理

1. シンプルなリレーショナルスキーマ
2. データパイプラインの利用

### 負荷の表現

現在の負荷を簡潔 r に表現できるようになって初めて、議論ができるようになる。

### パフォーマンスの表現

システムの負荷を表現できるようになれば、負荷が増大したときにおこることを調査できるようになる。

### 負荷への対処のアプローチ

スケールアップ：マシンの強力化
スケールアウト：マシンの分散化

## メンテナンス性

1. 運用性
2. 単純性
3. 進化性

# データモデルとクエリ言語
データモデル：問題に対する考え方に対して、極めて重大な影響力を持っている。

## リレーショナルモデルとドキュメントモデル

1. リレーショナルデータベース
   1. ビジネスデータの処理が期限
   2. クリーンなインターフェースによって背後の実装の詳細を隠蔽すること
2. NoSQL
   1. リレーショナルモデルの支配を終わらせようとする試み
   2. 極めて巨大なデータセットや優れた書き込みのスループット
   3. リレーショナルなスキーマの製薬に対するフラストレーション

## オブジェクトとリレーショナルのミスマッチ
多くのアプリケーション開発はオブジェクト指向で行われている。
インピーダンスマッチと呼ばれるデータ・ベースモデルのために変換レイヤーが必要になる。

ドキュメントのような構造モデルにはJSONが適している。

多対一と多対多の関係には正規化が鍵となるが、ドキュメントモデルよりもリレーショナルモデルが向いている。

過去にはこの関係によってリレーショナルモデル vs ネットワークモデルの論争があった。
ネットワークモデルは階層モデルであった。ツリー構造では、アクセスパスへの変更点が難しかった
リレーショナルモデルは変更が簡単。

ドキュメントデータベースでは、階層モデルにはあるが、多対多の関係の表現という点ではリレーショナルとドキュメントであまり差異はない。
リレーショナルでは外部キー、ドキュメントではドキュメント参照と呼ばれる

ドキュメント：スキーマオンリード→コレクションの中のアイテムの構造が統一されていない場合にメリットがある。
リレーショナル：スキーマオンライト

## データのためのクエリ言語
SQL：宣言的
IMS/CODASYL：命令的

SQLでは家庭に注目せず、結果を重要視する。
クエリの順序はクエリオプティマイザの判断に委ねられる。

宣言的なほうが命令的なものより使いやすい

## グラフ型のデータモデル

多対対のものであれば、グラフモデルが適している。

### プロパティグラフ
頂点
- ユニークな識別子
- 外向きの辺の集合
- 内向きの辺の集合
- プロパティのコレクション
辺
- ユニークな識別子
- 始点
- 終点
- 2つの頂点感の関係の種類を示すラベル
- プロパティのコレクション

### Cypherクエリ言語
例えば、グラフデータ・ベースによってアメリカからヨーロッパへ移住したすべての人々の名前を返すとする。
この場合、Cyperクエリであれば4行で書けるが、SQLだと29行ほどになる。

### トリプルストア

トリプルストアモデル：プロパティグラフと同じであるが、同じ概念を異なる用語で表現している。
トリプルストアでは、すべての情報は非常にシンプルな3つの部分からなる言明（主語、述語、目的語）の形で保存される。
例
-:lucy a :Person
-:lucy :name "Lucy"
-:lucy :bornIn _:idaho

トリプルストアはセマンティックWebと密接な関係性を持つ。


## まとめ
ドキュメントデータベース：データが自己完結しているドキュメント群で、ドキュメント間の関係がそれほど存在しないようなユースケースをターゲット
グラフデータベース：潜在的にはあらゆるもの同士に関係が存在するようなユースケースをターゲット

## ストレージと抽出
データ・ベースがやらなければいけないこと
1. 与えられたデータを保存すること
2. データを要求されたら返すこと

利用可能なストレージエンジンから自分のアプリケーションに適したエンジンを選択する必要がある。

データ・ベースから特定のキーの値を効率的に見つけるために、別のデータ構造であるインデックスが必要になる。
インデックスは読み出しのクエリを高速にするが、あらゆるインデックスは書き込みを低速にする。

### ハッシュインデックス
キーバリュー型のデータのためのインデックスー＞キーバリューストア
データストレージにはファイルへの追記だけを行う
インメモリのハッシュマップでは、すべてのキーに対してデータファイル中のバイトオフセットをマッピングする

ログが増えたら、ログ中で重複しているキーを捨てて、それぞれのキーに対する最新の情報だけを残すコンパクション処理を実施する。

キーに対する値の探し方
1. 最新のセグメントのハッシュマップをチェックする。
2. キーがなければ、二番目に新しいセグメントを探す
3. 以降同様に処理を進める。

検討事項
- ファイルフォーマット
- レコードの削除：データファイルに特別な削除レコードを追加する
- クラッシュのリカバリ：インメモリのハッシュマップのスナップショットをディスク上に保存する
- 部分的に書き込まれたレコード：チェックサム
- 並行性の制御：ログへの書き込みは直列、読み取りは並行に可能

追記のみのログは一見無駄があるように見えるが、利点がある。
1. ランダムな書き込みよりも高速である
2. 並行処理やクラッシュリカバリがシンプルになる
3. フラグメンテーションを避けられる

制約もある
1. ハッシュマップが大きくなると扱えなくなる。
2. 範囲に対するクエリの効率が良くない

### SSTableとLSMツリー
Sorted String Table: ソート済み文字列テーブル キーでソートされているセグメントファイル

SSTableの構築
- 書き込み要求が来たら、memtableと呼ばれるバランス度ツリーデータ構造に追加
- memtableが大きくなったらディスクに書き出しを行う
欠点としては、データベースクラッシュで直近の書き込みがうしなわれてしまう。
ディスク上に別個のログをもっておくと、防げる。

LSMツリー：Log-Structured Merge-Tree
ソート済みのファイルのマージとコンパクションを基盤とするストレージエンジン

パフォーマンスの最適化
- ブルームフィルタとよばれる集合の内容についての概要を保持するメモリ効率の良いデータ構造を用いると、不要なディスクの読み取りを防げる
- コンパクションとマージ順序とタイミングの決定で様々な戦略がある。
  - サイズごとおよび階層ごとのコンパクションが考えられる。
  - 




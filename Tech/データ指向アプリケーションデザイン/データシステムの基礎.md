# 信頼性、スケーラビリティ、メンテナンス性に優れたアプリケーション

現在のアプリケーションはデータ志向

データベース：データを保存し、のちにそのアプリケーション自身、もしくはほかのアプリケーションがそのデータを再度見つけられるようにする。
キャッシュ：処理量の多い操作の結果を覚えておき、読み取りの速度を高める。
検索インデックス：ユーザーがデータをキーワードで検索したり、様々な方法でフィルタリングしたり、できるようにする。
ストリーム処理：ほかのプロセスへメッセージを送り、非同期に処理をしてもらう。
バッチ処理：蓄積された大量のデータを定期的に処理する。

データシステムでは様々なツールを包括する用語として利用される。

1. ツールの差異があいまいになってきている。
2. 複数のツールを利用してデータを管理するケースが増えている。

データシステムにおける三つの課題

1. 信頼性
2. スケーラビリティ
3. メンテナンス性

信頼性：何か問題が生じたとしても正しく動作し続けること
fault：問題を起こしうるもの、障害とは異なる
fault tolerant、resilient：fault の存在を見越して対処できること

## 信頼性

1. ハードウェアの障害
2. ソフトウェアのエラー
   1. ソフトウェアのバグ
   2. プロセスの暴走
   3. 依存しているサービスの問題
   4. カスケード障害
3. ヒューマンエラー

## スケーラビリティ

Twitter のポスト処理

1. シンプルなリレーショナルスキーマ
2. データパイプラインの利用

### 負荷の表現

現在の負荷を簡潔 r に表現できるようになって初めて、議論ができるようになる。

### パフォーマンスの表現

システムの負荷を表現できるようになれば、負荷が増大したときにおこることを調査できるようになる。

### 負荷への対処のアプローチ

スケールアップ：マシンの強力化
スケールアウト：マシンの分散化

## メンテナンス性

1. 運用性
2. 単純性
3. 進化性

# データモデルとクエリ言語
データモデル：問題に対する考え方に対して、極めて重大な影響力を持っている。

## リレーショナルモデルとドキュメントモデル

1. リレーショナルデータベース
   1. ビジネスデータの処理が期限
   2. クリーンなインターフェースによって背後の実装の詳細を隠蔽すること
2. NoSQL
   1. リレーショナルモデルの支配を終わらせようとする試み
   2. 極めて巨大なデータセットや優れた書き込みのスループット
   3. リレーショナルなスキーマの製薬に対するフラストレーション

## オブジェクトとリレーショナルのミスマッチ
多くのアプリケーション開発はオブジェクト指向で行われている。
インピーダンスマッチと呼ばれるデータ・ベースモデルのために変換レイヤーが必要になる。

ドキュメントのような構造モデルにはJSONが適している。

多対一と多対多の関係には正規化が鍵となるが、ドキュメントモデルよりもリレーショナルモデルが向いている。

過去にはこの関係によってリレーショナルモデル vs ネットワークモデルの論争があった。
ネットワークモデルは階層モデルであった。ツリー構造では、アクセスパスへの変更点が難しかった
リレーショナルモデルは変更が簡単。

ドキュメントデータベースでは、階層モデルにはあるが、多対多の関係の表現という点ではリレーショナルとドキュメントであまり差異はない。
リレーショナルでは外部キー、ドキュメントではドキュメント参照と呼ばれる

ドキュメント：スキーマオンリード→コレクションの中のアイテムの構造が統一されていない場合にメリットがある。
リレーショナル：スキーマオンライト

## データのためのクエリ言語
SQL：宣言的
IMS/CODASYL：命令的

SQLでは家庭に注目せず、結果を重要視する。
クエリの順序はクエリオプティマイザの判断に委ねられる。

宣言的なほうが命令的なものより使いやすい

## グラフ型のデータモデル

多対対のものであれば、グラフモデルが適している。

### プロパティグラフ
頂点
- ユニークな識別子
- 外向きの辺の集合
- 内向きの辺の集合
- プロパティのコレクション
辺
- ユニークな識別子
- 始点
- 終点
- 2つの頂点感の関係の種類を示すラベル
- プロパティのコレクション

### Cypherクエリ言語
例えば、グラフデータ・ベースによってアメリカからヨーロッパへ移住したすべての人々の名前を返すとする。
この場合、Cyperクエリであれば4行で書けるが、SQLだと29行ほどになる。

### トリプルストア

トリプルストアモデル：プロパティグラフと同じであるが、同じ概念を異なる用語で表現している。
トリプルストアでは、すべての情報は非常にシンプルな3つの部分からなる言明（主語、述語、目的語）の形で保存される。
例
-:lucy a :Person
-:lucy :name "Lucy"
-:lucy :bornIn _:idaho

トリプルストアはセマンティックWebと密接な関係性を持つ。


## まとめ
ドキュメントデータベース：データが自己完結しているドキュメント群で、ドキュメント間の関係がそれほど存在しないようなユースケースをターゲット
グラフデータベース：潜在的にはあらゆるもの同士に関係が存在するようなユースケースをターゲット

## ストレージと抽出
データ・ベースがやらなければいけないこと
1. 与えられたデータを保存すること
2. データを要求されたら返すこと

利用可能なストレージエンジンから自分のアプリケーションに適したエンジンを選択する必要がある。

データ・ベースから特定のキーの値を効率的に見つけるために、別のデータ構造であるインデックスが必要になる。
インデックスは読み出しのクエリを高速にするが、あらゆるインデックスは書き込みを低速にする。

### ハッシュインデックス
キーバリュー型のデータのためのインデックスー＞キーバリューストア
データストレージにはファイルへの追記だけを行う
インメモリのハッシュマップでは、すべてのキーに対してデータファイル中のバイトオフセットをマッピングする

ログが増えたら、ログ中で重複しているキーを捨てて、それぞれのキーに対する最新の情報だけを残すコンパクション処理を実施する。

キーに対する値の探し方
1. 最新のセグメントのハッシュマップをチェックする。
2. キーがなければ、二番目に新しいセグメントを探す
3. 以降同様に処理を進める。

検討事項
- ファイルフォーマット
- レコードの削除：データファイルに特別な削除レコードを追加する
- クラッシュのリカバリ：インメモリのハッシュマップのスナップショットをディスク上に保存する
- 部分的に書き込まれたレコード：チェックサム
- 並行性の制御：ログへの書き込みは直列、読み取りは並行に可能

追記のみのログは一見無駄があるように見えるが、利点がある。
1. ランダムな書き込みよりも高速である
2. 並行処理やクラッシュリカバリがシンプルになる
3. フラグメンテーションを避けられる

制約もある
1. ハッシュマップが大きくなると扱えなくなる。
2. 範囲に対するクエリの効率が良くない

### SSTableとLSMツリー
Sorted String Table: ソート済み文字列テーブル キーでソートされているセグメントファイル

SSTableの構築
- 書き込み要求が来たら、memtableと呼ばれるバランス度ツリーデータ構造に追加
- memtableが大きくなったらディスクに書き出しを行う
欠点としては、データベースクラッシュで直近の書き込みがうしなわれてしまう。
ディスク上に別個のログをもっておくと、防げる。

LSMツリー：Log-Structured Merge-Tree
ソート済みのファイルのマージとコンパクションを基盤とするストレージエンジン

パフォーマンスの最適化
- ブルームフィルタとよばれる集合の内容についての概要を保持するメモリ効率の良いデータ構造を用いると、不要なディスクの読み取りを防げる
- コンパクションとマージ順序とタイミングの決定で様々な戦略がある。
  - サイズごとおよび階層ごとのコンパクションが考えられる。

### Bツリー
Bツリー：最も広く使われているインデックス構造

Bツリーではキーと値のペアをキーでソートされた状態で保持する。
が、SSTableと似ているのはこれだけ。

Bツリーでは、固定サイズのブロックもしくはページに分割する。
あるページから他のページへ参照できる。

分岐係数：Bツリーにおける1ページ内の小ページへの参照係数　通常数百程度
Bツリー内の既存のキーに板する値を更新したい場合は、キーを含むリーフページを検索し、そのページ内の値を更新してディスクに書き戻す

新しいキーを追加したい場合は、そのキーの値を含む範囲を持つページを見つけ、そのページにキーを追加する必要がある。
もし空き領域がない場合は、そのページを半分だけが埋まった2つのページに分割し親のページを配下にできた新しい2つのキーの範囲に合わせて更新する
ツリーのバランスが保たれるので深さは常にO(log n)になる

Bツリーの信頼性を高めるために、write-aheadログを用いる。
複数のスレッドが同時にBツリーにアクセスする場合、注意して並行処理をしなければ、整合性が保たれない。
そこで、ラッチでツリーのデータ構造を保護することで制御可能

### BツリーとLSMツリー
Bツリーは読み取りが高速、LSMツリーは書き込みが高速とみなされている

LSMツリーの利点：書き込みのスループットを高く保てる。また、圧縮率を高めることができる。
LSMツリーの欠点：コンパクションの処理が実行中の読み書きに影響がある。書き込みのスループットの高さでコンパクションに要するディスク容量が増えてしまう。

Bツリーの利点：インデックスの中にキーが1箇所しか存在しないため、強いトランザクションが必要な場合魅力的である。
Bツリーの欠点：書き込みでオーバーヘッドが生じる

### その他のインデックス構造
インデックスへの値の保存
結果の値は探していた実際の行もしくはどこか別の場所に保存されている行の参照の2種類が考えられる。
複数のセカンダリインデックスがある場合に、データ複製が避けられるため、ヒープファイルが使われる。

クラスタ化インデックス：インデックスつけされた行を直接インデックス内に保存するインデックス　辞書ごとアルファベット順
非クラスタ化インデックス：データへの参照だけをインデックス内に保存するインデックス　辞書の後ろにアルファベット順の索引

複合インデックス
標準的なBツリーやLSMツリーインデックスでは、効率的に二次元に対するクエリを回答できない。
二次元の一を単一の数値に変換してから通常のBツリーインデックスを使う
もしくは、Rツリーのような空間インデックスを使う方法がある。

レーベンシュタインオートマトン：ある特定の許容範囲内での「近い文字列」を効率よく検索するためのツール
検索エンジンやスペルチェック機能、オートコンプリートシステムなどで使われるらしい（生成AI調べ）